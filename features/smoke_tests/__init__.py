# -*- coding: utf-8 -*-

# Akvo RSR is covered by the GNU Affero General Public License.
# See more details in the license.txt file located at the root folder of the Akvo RSR module.
# For additional details on the GNU license please see < http://www.gnu.org/licenses/agpl.html >.

import itertools
import os
import re
import types
from django.core.urlresolvers import LocaleRegexURLResolver

from lettuce import world

os.environ['DJANGO_SETTINGS_MODULE'] = 'akvo.settings'


def path_template_and_args(pattern):
    """ given a url regex string return the path it represents with any arguments wrapped for string formatting
    and a list of argument names
    example: given r'^rsr/project/(?P<project_id>\d+)/update/(?P<update_id>\d+)/edit/$' return
    'rsr/project/{project_id}/update/{update_id}/edit/', ['project_id', 'update_id']
    :param pattern: a regex string from the urlconf patterns
    """
    # snip ^and $
    raw = pattern.regex.pattern[1:-1]
    # split the string into path bits and param names
    bits = re.split('\(.*?<|>.*?\)', raw)
    # no params
    if len(bits) < 2:
        return raw, []
        # each odd numbered bit is an argument name
    args = [bit for bit in bits[1::2]]
    template = []
    braces = ('{', '}')
    # wrap the arguments in braces
    for i, bit in enumerate(bits):
        template.append(bit)
        if i < len(bits) - 1:
            template.append(braces[i % 2])
    return ''.join(template), args

def all_paths(urlpatterns):
    """ Create a list of as many paths as possible from the RSR urlconf to be used creating a feature file for visiting
    all those pages
    Since many of the paths need data to be constructed, e.g. an ID of a certain object, use the world.url_params object
    to populate the params. If the needed params for a path are not in world.url_params the path will not be included in
    the final list
    If multiple values for a given param is in world.url_params, e.g. world.url_params.project_id = 43, 43, all paths
    using the combinations of the params are constructed
    :return: a list of all paths in RSR we want to visit
    :rtype: list
    """
    # the resulting list of fully expanded paths
    all_paths = []
    for pattern in urlpatterns:
        # determine if this path is to be included at all
        include = True
        path_template, arg_names = path_template_and_args(pattern)
        all_args = []
        for arg_name in arg_names:
            arg_values = (getattr(world.url_params, arg_name, False))
            if not arg_values:
                # can't construct a path if it needs params we have no values for
                include = False
                break
            if not (isinstance(arg_values, types.ListType) or isinstance(arg_values, types.TupleType)):
                # make a list of single values
                arg_values = [arg_values]
                # prepare for itertools.product
            all_args.append([(arg_name, value) for value in arg_values])
        if include:
            if all_args:
                # combine all arguments in all ways
                combos = list(itertools.product(*all_args))
                paths = []
                # insert the arguments into the path template
                for combo in combos:
                    paths.append(path_template.format(**dict(combo)))
            else:
                paths = [path_template]
            all_paths.extend(paths)
    return all_paths

def full_rsr_url_from_path(path):
    domain = world.SITE_UNDER_TEST
    return 'http://{domain}/{path}'.format(domain=domain, path=path)

def full_partner_site_url_from_path(path, locale):
    domain = world.PARTNER_SITE_UNDER_TEST
    return 'http://{domain}/{locale}{path}'.format(domain=domain, locale=locale, path=path)

def create_all_urls_smoke_test():
    """ Create a feature file, all_pages.feature, listing as many pages as possible in RSR to be visited
    The URLs that have one or more parameter need values for these in world.url_params,
    see doc string for all_rsr_paths() above
    """
    feature_template = """# NOTE This file is generated by the testing, don't edit it!
Feature: Smoke test RSR
    In order to be sure nothing blows up
    As an anonymous site visitor
    Visit every page in RSR

    Scenario: Visit all RSR pages
        Visit the page at {rsr_urls}

    Scenario: Visit all partner site pages
        Visit the page at {ps_urls}
"""
    from akvo.urls.rsr import urlpatterns as rsr_patterns
    paths = all_paths(rsr_patterns)
    exclude = world.url_params.exclude_rsr
    rsr_urls = [full_rsr_url_from_path(path) for path in paths if not path in exclude]
    rsr_urls = '\n        Visit the page at '.join(rsr_urls)

    from akvo.urls.partner_sites import urlpatterns as ps_patterns
    paths = []
    for pattern in ps_patterns:
        if type(pattern) == LocaleRegexURLResolver:
            locale_regex = pattern.regex.pattern[1:]
            paths.extend(all_paths(pattern.urlconf_name))
        else:
            # other paths not easily testable
            pass
    exclude = world.url_params.exclude_ps
    ps_urls = [full_partner_site_url_from_path(path, locale_regex) for path in paths if not path in exclude]
    ps_urls = '\n        Visit the page at '.join(ps_urls)

    feature_template = feature_template.format(rsr_urls=rsr_urls, ps_urls=ps_urls)
    with open('smoke_tests/all_pages.feature', 'w') as f:
        f.write(feature_template)
        f.close()